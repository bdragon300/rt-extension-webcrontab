<& /Admin/Elements/Header, Title => $title &>
<& /Elements/Tabs &>

<& /Elements/ListActions, actions => \@results &>

<style>
    .el span.label {
        display: block;
        text-align: left;
    }
    .elgrp div.el {
        display: inline-block;
        margin: 10px 5px;
        vertical-align: top;
    }
</style>

<form action="/Admin/Tools/WebCrontab/edit.html?id=<% $id %>&Create=<% $Create %>" method="post">
    <& Elements/CrontabEvent, filling => $available_values, data => $current_event, captions => $classes &>
    <& /Elements/Submit, Name => 'submit', Label => loc('Save Changes') &>
%   if ($Create == 0) {
        <& /Elements/Submit, Name => 'remove', Label => loc('REMOVE'), OnClick => "return confirm('" . loc("Do you want to remove event?") . "');" &>
%   }
</form>

<%init>
use Data::Dumper qw{Dumper};

my $title = loc('Crontab event');
unless ($session{'CurrentUser'}->HasRight( Object=> $RT::System, Right => 'SuperUser')) {
    Abort(loc('This feature is only available to system administrators'));
}

my $available_values = RT::Extension::WebCrontab::get_available_values();
my $classes = RT::Extension::WebCrontab::get_classes();

my $crontab = RT::Extension::WebCrontab::load_crontab();
my $events = $crontab->{'events'};
undef $crontab;

my @results;
my $current_event = {};

$id += 0;
$Create += 0;
unless ($Create) {
    if ( ! defined($events->[$id])
        || $events->[$id]->{'skip'})
    {
        Abort(loc('ERROR: Invalid id'));
    }
}


unless ($Create) {
    $current_event = $events->[$id];
    delete @$current_event{qw/obj skip/}; # delete not significant keys
    # FIXME: delete keys with undef values
}

if ($ARGS{'remove'}) {
    splice(@$events, $id, 1);

    my ($res, $msg) = RT::Extension::WebCrontab::save_events($events);
    if ($res) {
        push @results, loc('Crontab saved');
    } else {
        push @results, loc('ERROR: Cannot save crontab: [_1]', $msg);
    }

    MaybeRedirectForResults(
        Actions   => \@results,
        Path      => "/Admin/Tools/WebCrontab"
    );
}

if ($ARGS{'submit'}) {
    my %new_event = map { $_ => $ARGS{$_} } 
        grep { $ARGS{$_} } 
        (@$classes, 'expression');
    my %old_event = map { $_ => $ARGS{'old-' . $_} } 
        grep { $ARGS{'old-' . $_} } 
        (@$classes, 'expression');

    if ($new_event{'expression'} !~ /^(([\d,*\/-]+ ){4}[\d,*\/-]+)|(@[a-z]+)$/) {  # FIXME: mon-sun expressions do not match, 0 0 0 0 0 match
        push @results, "ERROR: Incorrect crontab expression";
    }

    # Make sure that current crontab event and the old event (had been existing by edit) must be identical
    unless ($Create) {
        no warnings;  # smartmatch op use
        if ( ! (%old_event ~~ %$current_event)
            || (grep {$current_event->{$_} ne $old_event{$_}} keys %$current_event))
        {
            push @results, loc("ERROR: Crontab changed since last read. Changes was loaded");
        }
    }
    
    unless (@results) {
        $id = scalar(@$events) if ($Create);
        $events->[$id] = \%new_event;

        my ($res, $msg) = RT::Extension::WebCrontab::save_events($events);

        if ($res) {
            push @results, loc('Crontab saved');
        } else {
            push @results, loc('ERROR: Cannot save crontab: [_1]', $msg);
        }

        MaybeRedirectForResults(
            Actions   => \@results,
            Path      => "/Admin/Tools/WebCrontab"
        );
    }
}
</%init>

<%args>
$id => 0
$Create => 0
$Remove => 0
</%args>